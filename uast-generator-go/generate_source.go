// The following directive is necessary to make the package coherent:
// +build ignore

// This program generates 'goparser_generated.go'. It can be invoked by running "go generate"
package main

import (
	"bytes"
	"go/ast"
	"go/token"
	"io/ioutil"
	"reflect"
)

func main() {
	var out bytes.Buffer

	out.WriteString(`// Code generated by 'generate_source.go' using 'go generate'; DO NOT EDIT.
package main

import (
	"go/ast"
	"strconv"
)
`)

	context := AstContext{
		Out: &out,
		KindsPerType: []*TypeKind{
			// structs
			NewTypeKind((*ast.File)(nil), "COMPILATION_UNIT"),
			NewTypeKind((*ast.FuncDecl)(nil), "FUNCTION"),
			NewTypeKind((*ast.BlockStmt)(nil), "BLOCK"),
			NewTypeKind((*ast.IfStmt)(nil), "IF"),
			NewTypeKind((*ast.Ident)(nil), "IDENTIFIER"),
			NewTypeKind((*ast.AssignStmt)(nil), "ASSIGNMENT"),
			NewTypeKind((*ast.BasicLit)(nil), "LITERAL"),
			NewTypeKind((*ast.ExprStmt)(nil), "EXPRESSION"),
			NewTypeKind((*ast.BinaryExpr)(nil), "BINARY_EXPRESSION"),
			NewTypeKind((*ast.CallExpr)(nil), "CALL"),
			NewTypeKind((*ast.SelectorExpr)(nil), "SELECTOR_EXPR"),
			NewTypeKind((*ast.SwitchStmt)(nil), "SWITCH"),
			NewTypeKind((*ast.CaseClause)(nil), "CASE"),
			NewTypeKind((*ast.BadDecl)(nil), "UNSUPPORTED"),
			NewTypeKind((*ast.BadExpr)(nil), "UNSUPPORTED"),
			NewTypeKind((*ast.BadStmt)(nil), "UNSUPPORTED"),
			NewTypeKind((*ast.StructType)(nil), "CLASS"),
			NewTypeKind((*ast.InterfaceType)(nil), "CLASS"),
			// interfaces
			NewTypeKind((*ast.Stmt)(nil), "STATEMENT"),
		},
		KindsPerName: map[string]string{
			"File#Decls":           "DECL_LIST",
			"FuncDecl#Recv":        "PARAMETER_LIST",
			"FuncType#Params":      "PARAMETER_LIST",
			"FuncType#Results":     "RESULT_LIST",
			"FuncTypeDecl#Params":  "PARAMETER_LIST",
			"FuncTypeDecl#Results": "RESULT_LIST",
			"FieldParam#Names[i]":  "PARAMETER",
			"FieldResult#Names[i]": "RESULT",
			"ParenExpr#Lparen":     "LPAREN",
			"ParenExpr#Rparen":     "RPAREN",
			"CallExpr#Lparen":      "LPAREN",
			"CallExpr#Rparen":      "RPAREN",
			"CallExpr#Args":        "ARGS_LIST",
			"AssignStmt#Lhs":       "ASSIGNMENT_TARGET",
			"AssignStmt#Rhs":       "ASSIGNMENT_VALUE",
			"CaseClause#List[i]":   "CONDITION",
			"IfStmt#Else":          "ELSE",
		},
		KindsPerTypeException: map[reflect.Type]reflect.Type{
			typeOf((*ast.BlockStmt)(nil)):   typeOf((*ast.Stmt)(nil)),
			typeOf((*ast.LabeledStmt)(nil)): typeOf((*ast.Stmt)(nil)),
			typeOf((*ast.CaseClause)(nil)):  typeOf((*ast.Stmt)(nil)),
			typeOf((*ast.CommClause)(nil)):  typeOf((*ast.Stmt)(nil)),
		},
		NoNodeForFieldList: map[string]bool{
			"FieldListParams#List":  true,
			"FieldListResults#List": true,
			"BlockStmt#List":        true,
			"CaseClause#List":       true,
		},
		MergeFieldIntoParent: map[string]bool{
			"SwitchStmt#Body": true,
		},
		TypeToIgnore: map[string]bool{
			"*ast.CommentGroup":      true,
			"*ast.Object":            true,
			"*ast.Scope":             true,
			"bool":                   true,
			"[]*ast.CommentGroup":    true,
			"map[string]*ast.File":   true,
			"map[string]*ast.Object": true,
		},
		ForceLeafNode: map[string]bool{
			"Ident":    true,
			"BasicLit": true,
			"BadStmt":  true,
			"BadDecl":  true,
			"BadExpr":  true,
		},
		FieldToIgnore: map[string]bool{
			"File#Imports":    true,
			"File#Unresolved": true,

			"ChanType#Begin":    true,
			"ChanType#Arrow":    true,
			"ChanType#Dir":      true,
			"ImportSpec#EndPos": true,

			"FuncTypeDecl#Func": true,
		},
		TokenFieldWithPos: map[string]bool{
			"GenDecl#TokPos":    true,
			"AssignStmt#TokPos": true,
			"BranchStmt#TokPos": true,
			"IncDecStmt#TokPos": true,
			"RangeStmt#TokPos":  true,
			"BinaryExpr#OpPos":  true,
			"UnaryExpr#OpPos":   true,
		},
		StructVariations: map[string][]string{
			// dissociate to distinguish delimiters '('/'{' and kinds PARAMETER/RESULT
			"FieldList": []string{"Params", "Results", "Brace"},
			"Field":     []string{"", "Result", "Param"},
			// "func" is consumed from FuncDecl.Type.Func but not from FuncLit or ast.Expr
			"FuncType": []string{"", "Decl"},
		},
		FieldVariationMap: map[string]string{
			"StructType#Fields":        "Brace",
			"InterfaceType#Methods":    "Brace",
			"FuncType#Params":          "Params",
			"FuncType#Results":         "Results",
			"FuncTypeDecl#Params":      "Params",
			"FuncTypeDecl#Results":     "Results",
			"FuncDecl#Type":            "Decl",
			"FuncDecl#Recv":            "Params",
			"FieldListParams#List[i]":  "Param",
			"FieldListResults#List[i]": "Result",
		},
		MatchingTokenPos: map[string]token.Token{
			"Lbrace":                   token.LBRACE,
			"Rbrace":                   token.RBRACE,
			"Lbrack":                   token.LBRACK,
			"Rbrack":                   token.RBRACK,
			"Lparen":                   token.LPAREN,
			"Rparen":                   token.RPAREN,
			"Colon":                    token.COLON,
			"Semicolon":                token.SEMICOLON,
			"Star":                     token.MUL,
			"TypeSpec#Assign":          token.ASSIGN,
			"FieldListParams#Opening":  token.LPAREN,
			"FieldListParams#Closing":  token.RPAREN,
			"FieldListResults#Opening": token.LPAREN,
			"FieldListResults#Closing": token.RPAREN,
			"FieldListBrace#Opening":   token.LBRACE,
			"FieldListBrace#Closing":   token.RBRACE,
			"GoStmt#Go":                token.GO,
			"IfStmt#If":                token.IF,
			"SendStmt#Arrow":           token.ARROW,
			"Ellipsis":                 token.ELLIPSIS,
			"ForStmt#For":              token.FOR,
			"RangeStmt#For":            token.FOR,
			"MapType#Map":              token.MAP,
			"FuncType#Func":            token.FUNC,
			"DeferStmt#Defer":          token.DEFER,
			"ReturnStmt#Return":        token.RETURN,
			"SelectStmt#Select":        token.SELECT,
			"SwitchStmt#Switch":        token.SWITCH,
			"TypeSwitchStmt#Switch":    token.SWITCH,
			"StructType#Struct":        token.STRUCT,
			"InterfaceType#Interface":  token.INTERFACE,
		},
		InsertBeforeField: map[string]string{
			"FuncDecl#Recv": "children = t.appendNode(children, " +
				"t.createUastExpectedToken(nil, astNode.Type.Func, \"func\", \"Type.Func\"))",
		},
		OverrideField: map[string]string{
			"File#Package": "children = t.appendNode(children, t.mapPackageDecl(astNode))",
			"File#Name":    "",
			// unknown "case" or "default"
			"CaseClause#Case": "children = t.appendNode(children, " +
				"t.createCaseOrDefaultToken(astNode.Case, len(astNode.List) == 0, \"Case\"))",
			"CommClause#Case": "children = t.appendNode(children, " +
				"t.createCaseOrDefaultToken(astNode.Case, astNode.Comm == nil, \"Case\"))",
			"IfStmt#Init": "",
			"IfStmt#Cond": "children = t.appendNode(children, " +
				"t.createAdditionalInitAndCond(astNode.Init, astNode.Cond))",
		},
		ListWithMissingSeparator: map[string]bool{
			"FieldList#List":    true,
			"BlockStmt#List":    true,
			"CallExpr#Args":     true,
			"CompositeLit#Elts": true,
		},
		TypeQueue: []reflect.Type{
			typeOf((*ast.File)(nil)),
		},
		TypeProcessed: map[reflect.Type]bool{},
		AllAstStruct: typeOfList((*ast.ArrayType)(nil), (*ast.AssignStmt)(nil), (*ast.BadDecl)(nil),
			(*ast.BadExpr)(nil), (*ast.BadStmt)(nil), (*ast.BasicLit)(nil), (*ast.BinaryExpr)(nil),
			(*ast.BlockStmt)(nil), (*ast.BranchStmt)(nil), (*ast.CallExpr)(nil), (*ast.CaseClause)(nil),
			(*ast.ChanType)(nil), (*ast.CommClause)(nil), (*ast.CommentGroup)(nil), (*ast.Comment)(nil),
			(*ast.CompositeLit)(nil), (*ast.DeclStmt)(nil), (*ast.DeferStmt)(nil), (*ast.Ellipsis)(nil),
			(*ast.EmptyStmt)(nil), (*ast.ExprStmt)(nil), (*ast.FieldList)(nil), (*ast.Field)(nil), (*ast.File)(nil),
			(*ast.ForStmt)(nil), (*ast.FuncDecl)(nil), (*ast.FuncLit)(nil), (*ast.FuncType)(nil), (*ast.GenDecl)(nil),
			(*ast.GoStmt)(nil), (*ast.Ident)(nil), (*ast.IfStmt)(nil), (*ast.ImportSpec)(nil), (*ast.IncDecStmt)(nil),
			(*ast.IndexExpr)(nil), (*ast.InterfaceType)(nil), (*ast.KeyValueExpr)(nil), (*ast.LabeledStmt)(nil),
			(*ast.MapType)(nil), (*ast.Package)(nil), (*ast.ParenExpr)(nil), (*ast.RangeStmt)(nil),
			(*ast.ReturnStmt)(nil), (*ast.SelectorExpr)(nil), (*ast.SelectStmt)(nil), (*ast.SendStmt)(nil),
			(*ast.SliceExpr)(nil), (*ast.StarExpr)(nil), (*ast.StructType)(nil), (*ast.SwitchStmt)(nil),
			(*ast.TypeAssertExpr)(nil), (*ast.TypeSpec)(nil), (*ast.TypeSwitchStmt)(nil), (*ast.UnaryExpr)(nil),
			(*ast.ValueSpec)(nil),
		),
	}
	context.Execute()

	err := ioutil.WriteFile("goparser_generated.go", out.Bytes(), 0644)
	if err != nil {
		panic(err)
	}
}

func typeOf(pointer interface{}) reflect.Type {
	return reflect.TypeOf(pointer).Elem()
}

func typeOfList(pointerList ...interface{}) []reflect.Type {
	types := []reflect.Type{}
	for _, structPointer := range pointerList {
		types = append(types, reflect.TypeOf(structPointer).Elem())
	}
	return types
}

type TypeKind struct {
	structOrInterface reflect.Type
	kind              string
}

func NewTypeKind(pointer interface{}, kind string) *TypeKind {
	return &TypeKind{
		structOrInterface: reflect.TypeOf(pointer).Elem(),
		kind:              kind,
	}
}

type AstContext struct {
	Out                      *bytes.Buffer
	TypeToIgnore             map[string]bool
	ForceLeafNode            map[string]bool
	FieldToIgnore            map[string]bool
	TokenFieldWithPos        map[string]bool
	MatchingTokenPos         map[string]token.Token
	KindsPerType             []*TypeKind
	NoNodeForFieldList       map[string]bool
	MergeFieldIntoParent     map[string]bool
	KindsPerTypeException    map[reflect.Type]reflect.Type
	KindsPerName             map[string]string
	InsertBeforeField        map[string]string
	OverrideField            map[string]string
	ListWithMissingSeparator map[string]bool
	StructVariations         map[string][]string
	FieldVariationMap        map[string]string
	TypeQueue                []reflect.Type
	TypeProcessed            map[reflect.Type]bool
	AllAstStruct             []reflect.Type
}

func (t *AstContext) Execute() {
	for len(t.TypeQueue) > 0 {
		nextType := t.TypeQueue[0]
		t.TypeQueue = t.TypeQueue[1:]
		t.TypeProcessed[nextType] = true
		t.visitType(nextType)
	}
}

func (t *AstContext) pushType(structType reflect.Type) {
	if !t.TypeProcessed[structType] && !t.TypeToIgnore[structType.String()] {
		t.TypeProcessed[structType] = true
		t.TypeQueue = append(t.TypeQueue, structType)
	}
}

func (t *AstContext) writeLn(text string) {
	t.Out.WriteString(text)
	t.Out.WriteString("\n")
}

func (t *AstContext) visitType(nextType reflect.Type) {
	switch nextType.Kind() {
	case reflect.Interface:
		t.visitInterfaceType(nextType)
	case reflect.Struct:
		t.visitStructType(nextType)
	default:
		panic("Unsupported Kind " + nextType.Kind().String() + " for type " + nextType.String())
	}
}

func (t *AstContext) visitInterfaceType(interfaceType reflect.Type) {
	if interfaceType.Kind() != reflect.Interface {
		panic("Expect a Interface")
	}
	t.writeLn("")
	methodName := "map" + interfaceType.Name()
	arguments := "astNode " + interfaceType.String() + ", kinds []Kind, nativeNode string"
	t.writeLn("func (t *UastMapper) " + methodName + "(" + arguments + ") *Node {")
	t.writeLn("\tswitch node := astNode.(type) {")
	for _, astStruct := range t.getStructTypesThanImplement(interfaceType) {
		if !t.TypeToIgnore[astStruct.String()] {
			t.writeLn("\tcase *" + astStruct.String() + ":")
			t.writeLn("\t\treturn t.map" + astStruct.Name() + "(node, kinds, nativeNode)")
			t.pushType(astStruct)
		} else {
			t.writeLn("\t// ignore " + astStruct.String() + " intentionally")
		}
	}
	t.writeLn("\tdefault:")
	t.writeLn("\t\treturn nil")
	t.writeLn("\t}")
	t.writeLn("}")
}

func (t *AstContext) visitStructType(structType reflect.Type) {
	if structType.Kind() != reflect.Struct {
		panic("Expect a Struct")
	}
	variations := t.StructVariations[structType.Name()]
	if len(variations) == 0 {
		variations = []string{""}
	}
	for _, variation := range variations {
		t.writeLn("")
		methodName := "map" + structType.Name() + variation
		arguments := "astNode *" + structType.String() + ", kinds []Kind, fieldName string"
		t.writeLn("func (t *UastMapper) " + methodName + "(" + arguments + ") *Node {")
		t.writeLn("\tif astNode == nil {")
		t.writeLn("\t\treturn nil")
		t.writeLn("\t}")
		t.writeLn("\tvar children []*Node")
		if !t.ForceLeafNode[structType.Name()] {
			for i := 0; i < structType.NumField(); i++ {
				field := structType.Field(i)
				fullName := structType.Name() + variation + "#" + field.Name
				t.visitField(fullName, structType, field)
			}
		}
		t.appendKindsByType("kinds", structType)
		arguments = "kinds, astNode, children, fieldName + \"(" + structType.Name() + ")\""
		t.writeLn("\treturn t.createUastNode(" + arguments + ")")
		t.writeLn("}")
	}
}

func (t *AstContext) visitField(fullName string, structType reflect.Type, field reflect.StructField) {
	codeBefore := t.InsertBeforeField[fullName]
	if len(codeBefore) > 0 {
		t.writeLn("\t" + codeBefore)
	}
	overrideCode, isOverridden := t.OverrideField[fullName]
	if isOverridden && len(overrideCode) > 0 {
		t.writeLn("\t" + overrideCode)
	}
	fieldType := field.Type
	if !isOverridden && !t.TypeToIgnore[fieldType.String()] && !t.FieldToIgnore[fullName] {
		switch fieldType.Kind() {
		case reflect.Ptr, reflect.Struct, reflect.Interface:
			t.visitStructField(fullName, field.Name, fieldType)
		case reflect.Slice:
			t.visitSliceField(fullName, field.Name, fieldType)
		case reflect.Int:
			t.visitIntField(fullName, field, fieldType)
		default:
			panic("Unsupported Kind " + fieldType.Kind().String() + " for type " + fieldType.String())
		}
	}
}

func (t *AstContext) visitStructField(fullName, name string, fieldType reflect.Type) {
	mappedField := t.mapField(fullName, fieldType, "astNode."+name, name)
	if t.MergeFieldIntoParent[fullName] {
		t.writeLn("\tchildren, kinds = t.mergeNode(children, kinds, " + mappedField + ")")
	} else {
		t.writeLn("\tchildren = t.appendNode(children, " + mappedField + ")")
	}
}

func (t *AstContext) visitSliceField(fullName, name string, sliceType reflect.Type) {
	elemType := sliceType.Elem()
	parentListName := "children"
	createParentList := !t.NoNodeForFieldList[fullName]
	if createParentList {
		parentListName = "nodeList" + name
		t.writeLn("\tvar " + parentListName + " []*Node")
	}
	t.writeLn("\tfor i := 0; i < len(astNode." + name + "); i++ {")
	fieldMapping := t.mapField(fullName+"[i]", elemType, "astNode."+name+"[i]", "[\" + strconv.Itoa(i) + \"]")
	t.writeLn("\t\t" + parentListName + " = t.appendNode(" + parentListName + ", " + fieldMapping + ")")
	t.writeLn("\t}")
	if createParentList {
		kinds := t.getKindsByFullName(fullName)
		var typeName string
		if elemType.Kind() == reflect.Ptr {
			typeName = "*" + elemType.Elem().Name()
		} else {
			typeName = elemType.Name()
		}
		arguments := "children, " + parentListName + ", " + kinds + ", \"" + name + "([]" + typeName + ")\""
		t.writeLn("\tchildren = t.appendNodeList(" + arguments + ")")
	}
}

func (t *AstContext) visitIntField(fullName string, field reflect.StructField, fieldType reflect.Type) {
	if fieldType.String() == "token.Pos" && t.TokenFieldWithPos[fullName] {
		// ignore, will be added by the "token.Token" field
		return
	}
	token := t.MatchingTokenPos[fullName]
	if token == 0 {
		token = t.MatchingTokenPos[field.Name]
	}
	var tokenPos string
	var tokenString string
	if fieldType.String() == "token.Token" && t.TokenFieldWithPos[fullName+"Pos"] {
		tokenPos = "astNode." + field.Name + "Pos"
		tokenString = "astNode." + field.Name + ".String()"
	} else if fieldType.String() == "token.Pos" && token != 0 {
		tokenPos = "astNode." + field.Name
		tokenString = "\"" + token.String() + "\""
	}
	if len(tokenString) > 0 {
		arguments := t.getKindsByFullName(fullName) + ", " + tokenPos + ", " + tokenString + ", \"" + field.Name + "\""
		mappedField := "t.createUastExpectedToken(" + arguments + ")"
		if t.MergeFieldIntoParent[fullName] {
			t.writeLn("\tchildren, kinds = t.mergeNode(children, kinds, " + mappedField + ")")
		} else {
			t.writeLn("\tchildren = t.appendNode(children, " + mappedField + ")")
		}
	} else {
		panic("Unsupported Int Kind " + fullName + " " + fieldType.String())
	}
}

func (t *AstContext) getKindsByFullName(fullName string) string {
	kinds := t.KindsPerName[fullName]
	if len(kinds) == 0 {
		return "nil"
	}
	return "[]Kind{" + kinds + "}"
}

func (t *AstContext) appendKindsByType(fieldName string, elemType reflect.Type) {
	for _, typeKind := range t.KindsPerType {
		if elemType == typeKind.structOrInterface || t.elemTypeImplements(elemType, typeKind.structOrInterface) {
			t.writeLn("\t" + fieldName + " = append(" + fieldName + ", " + typeKind.kind + ")")
		}
	}
}

func (t *AstContext) elemTypeImplements(elemType reflect.Type, interfaceType reflect.Type) bool {
	if interfaceType.Kind() != reflect.Interface || t.KindsPerTypeException[elemType] == interfaceType {
		return false
	}
	return reflect.PtrTo(elemType).Implements(interfaceType)
}

func (t *AstContext) mapField(fullName string, fieldType reflect.Type, name, fieldName string) string {
	addressPrefix := "&"
	if fieldType.Kind() == reflect.Ptr {
		fieldType = fieldType.Elem()
		addressPrefix = ""
	}
	if fieldType.Kind() == reflect.Interface {
		addressPrefix = ""
	} else if fieldType.Kind() != reflect.Struct {
		panic("Unsupported Kind " + fieldType.Kind().String() + " for " + name + " " + fieldType.String())
	}
	t.pushType(fieldType)
	methodMane := "t.map" + fieldType.Name() + t.FieldVariationMap[fullName]
	kinds := t.getKindsByFullName(fullName)
	return methodMane + "(" + addressPrefix + name + ", " + kinds + ", \"" + fieldName + "\")"
}

func (t *AstContext) getStructTypesThanImplement(interfaceType reflect.Type) []reflect.Type {
	list := []reflect.Type{}
	for _, astStruct := range t.AllAstStruct {
		if reflect.PtrTo(astStruct).Implements(interfaceType) {
			list = append(list, astStruct)
		}
	}
	return list
}
