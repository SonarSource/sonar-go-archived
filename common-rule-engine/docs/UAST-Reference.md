# Universal Abstract Syntax Tree - Reference Documentation

An UAST is a tree representation of a source code, which is language-independent.
It allows code quality rules enforcement targeting multiple languages.

For example, the UAST of this Go source code
[lets.go](../../sonar-go-plugin/src/test/resources/org/sonar/go/plugin/CpdVisitorTest/lets.go)
is
[lets.go.uast.json](../../sonar-go-plugin/src/test/resources/org/sonar/go/plugin/CpdVisitorTest/lets.go.uast.json)

It is composed with a tree of [UastNode](../../common-rule-engine/src/main/java/org/sonar/uast/UastNode.java).
The tree structure matches the structure of the AST provided by the native parser of a given language.
So the structure of the tree is not normalized and changes from one language to another.
Only the **kinds** applied on each node are normalized and language-independent.

[Kinds Hierarchy and Properties](UAST-Kinds.md)

## UastNode structure

**Types of object**

### common attributes

* kinds (optional, array of string): kinds of the AST note
* nativeNode (optional, string): free text containing native parser information for debug purpose

e.g.
```
{
  "kinds": ["IDENTIFIER", "ASSIGNMENT_TARGET"],
  "nativeNode": "ident",
  ...
}
```

### node

Always contains at least 1 child.

* children (mandatory, array of object): ordered list of node or leaf

e.g.
```
{
  "kinds": ["ASSIGNMENT"],
  "children": [
    ….
  ]
}
```

### leaf

Has no children but matches source code tokens.

* token (mandatory)
* line (number): start at 1, position in the source code
* column (number): start at 1, position in the source code
* value (string): chunk of source code
* generated (optional, boolean): true for token generated by a pre-processor, only provided by parsers that generate some tokens that has no position in the source code, for example during marco or copybook expansion.

e.g.
```
{
  "kinds": ["IDENTIFIER"],
  "token": { "line": 1, "column": 1, "value": "x" }
}
```

### root
It's a node but also:

* Has kind "COMPILATION_UNIT"
* It's last children is the eof token

e.g.
```
{
  "kinds": ["COMPILATION_UNIT"],
  "children": [
    ….
  ]
}
```

### eof

It's a leaf with the kind "EOF". It shows the number of line of the source file. It's the only leaf with an empty value. "line" and "column" match a nonexisting character that follow the last character of the file.

e.g.
```
    {
      "kinds": ["EOF"],
      "token": { "line": 123, "column": 1, "value": "" }
    }
```

### comment

It's a leaf with the kind "COMMENT" (and optionally also the kind "STRUCTURED_COMMENT").

e.g.
```
    {
      "kinds": ["COMMENT"],
      "token": { "line": 12, "column": 5, "value": "/* TODO */" }
    },
    {
      "kinds": ["COMMENT", "STRUCTURED_COMMENT"],
      "token": { "line": 12, "column": 5, "value": "/** this class ... */" }
    }
```
